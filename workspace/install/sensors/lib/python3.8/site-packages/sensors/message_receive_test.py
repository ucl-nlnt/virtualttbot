import rclpy
import time
import threading
import socket
import sys
import struct

from rclpy.node import Node
from nav_msgs.msg import Odometry
from rclpy.qos import qos_profile_sensor_data
from geometry_msgs.msg import Twist
from gazebo_msgs.msg import ModelState
from geometry_msgs.msg import Quaternion
import random
import math

"""
Note that the following code was tested in a simulator and might not necessarily work on a real, physical turtlebot.
If the process requires anything GPU-related, I am 99% certain that it will not work at all.

Test system specs:
Processor: AMD Ryzen 5 5600H
RAM: 16GB LPDDR4 3200MHz (Dual-channel)
GPU: Nvidia RTX 3050ti

Edit (Nov. 24, 2023)
File has been updated to work on Turtlebot3 (MIGHT BE SLOW)
"""

class SensorsSubscriber(Node):

    def __init__(self, server_ip_address, transmit_to_server = True):

        super().__init__('sensors_subscriber')

        # Subscriptions
        # self.create_subscription(LaserScan, 'scan', self.scan_listener, qos_profile_sensor_data)
        # self.create_subscription(Twist,'cmd_vel', self.cmd_vel_listener, qos_profile_sensor_data)
        # ^ does not seem to contribute much -Gab
        # self.create_subscription(Imu,'imu', self.imu_listener, qos_profile_sensor_data) # IMU data doesn't seem to be useful currently

        self.create_subscription(Odometry, 'odom', self.odometry_listener, qos_profile_sensor_data)
        self.movement_server = self.create_publisher(Twist, '/cmd_vel',10)
        self.gazebo_model_state_publisher = self.create_publisher(ModelState,'/gazebo/set_model_state',10)

        self.order_clear_timer = self.create_timer(0.1, self.order_clear)
        

        # Odometry variables:
        self.position_odom = [None,None,None]
        self.rotation_odom = None

        # Instruction variables
        self.last_order = '@0000'
        self.time_last_order_issued = 0.0
        self.velocity_change = False
        
        self.twist_msg = [None, None] # linear x, angular z
        self.debug = True
        # Scanner variables:
        # empty for now

        self.transmit_to_server = transmit_to_server

        if self.transmit_to_server:
            self.client = socket.socket()
            server_ip = server_ip_address

            server_port = 50000;
            flag_connected = False

            try:
                self.client.connect((server_ip, server_port))
                print("[SensorsSubscriber] Connected to server.")
                flag_connected = True

            except Exception as e:
                print(e)
                print("[SensorsSubscriber] Error has occured when trying to connect to server.")

            if not flag_connected:
                print("[SensorsSubscriber] Exiting program...")
                sys.exit() # Close program if unable to connect to server

        # Data transmission thread
        self.tx_thread = threading.Thread(target = self.data_bridge_tx_TwistOdometry)
        self.tx_thread.start()

    def order_clear(self):
        if time.time() - self.time_last_order_issued >= 0.1:
            pass

    def twist_listener(self, msg = None):
        
        if msg == None: return
        
        self.twist_msg = [msg.linear.x, msg.angular.z]

    def odometry_listener(self, msg = None):

        if msg == None: return
        # Odometer listener

        self.position_odom = [msg.pose.pose.position.x, msg.pose.pose.position.y, msg.pose.pose.orientation.z] # x, y, phi
       
    def data_bridge_tx_TwistOdometry(self):

        if not self.transmit_to_server: return # error handling

        
        initializer_lock = True
        bridge_is_active = True
        while bridge_is_active:

            # STATE 3
            if initializer_lock:
                
                print("waiting for START...")
                data = self.receive_data()
                print(data.decode())
                print("START signal received. Sending prelimenary odometry data.")
                self.send_data(str(self.position_odom))
                print("Prelimenary odometry data sent.")
                initializer_lock = False

            else: # wait for instructions here

                instruction = self.receive_data().decode()

                if instruction == '@FRWD': self.movement(0.22,0.0) # forward
                elif instruction == '@LEFT': self.movement(0.0,1.5) # turn left
                elif instruction == '@RGHT': self.movement(0.0,-1.5) # turn right
                elif instruction == '@0000': self.movement(0.0,0.0) # stop moving
                elif instruction == '@ODOM': self.send_data(str(self.position_odom)) # send odometry data
                elif instruction == '@STOP': initializer_lock = True # end current data capture iteration
                elif instruction == '@KILL': sys.exit() # close Turtlebot3 program
                elif instruction == '@RNDM': 
                    print(self.position_odom)
                    self.set_turtlebot_model_state()
                    print(self.position_odom)
          

    def movement(self, linear_x, angular_z):

        twist = Twist()
        twist.linear.x = linear_x
        twist.angular.z = angular_z
        self.movement_server.publish(twist)
        return
    
    def send_data(self, data: bytes):

        if isinstance(data, str):
            data = data.encode()

        # NOTE: data may or may not be in string format.
            
        length_bytes = struct.pack('!I', len(data))
        
        if self.debug: print('[S] Sending byte length...')
        self.client.sendall(length_bytes)
        ack = self.client.recv(2) # wait for other side to process data size
        if ack != b'OK': print(f'[S] ERROR: unmatched send ACK. Received: {ack}')
        if self.debug: print('[S] ACK good')

        if self.debug: print('[S] Sending data...')
        self.client.sendall(data) # send data
        if self.debug: print('[S] Data sent; waiting for ACK...')
        ack = self.client.recv(2) # wait for other side to process data size
        if ack != b'OK': print(f'[S] ERROR: unmatched send ACK. Received: {ack}')
        if self.debug: print('[S] ACK good. Data send success.')

    def receive_data(self):

        # NOTE: Returns data in BINARY. You must decode it on your own

        if self.debug: print('[R] Waiting for byte length...')
        length_bytes = self.client.recv(4)
        length = struct.unpack('!I', length_bytes)[0]
        if self.debug: print(f'[R] Byte length received. Expecting: {length}')
        data, data_size = b'', 0

        self.client.send(b'OK') # allow other side to send over the data
        if self.debug: print(f'[R] ACK sent.')
        while data_size < length:

            chunk_size = min(2048, length - data_size)
            data_size += chunk_size
            data += self.client.recv(chunk_size)
            if self.debug: print(f'[R] RECV {chunk_size}')

        if self.debug: print('[R] Transmission received successfull. Sending ACK')       
        self.client.send(b'OK') # unblock other end
        if self.debug: print('[R] ACK sent.')
        return data # up to user to interpret the data

    def generate_quaternion_z(self, angle = None):
        
        if angle == None:
            angle = random.uniform(0, 2 * math.pi)
    
        quat = Quaternion()
        quat.z = math.sin(angle / 2)
        quat.w = math.cos(angle / 2)
        return quat

    def set_turtlebot_model_state(self, x = random.uniform(-5,5), y = random.uniform(-5,5), orient = None):

        state = ModelState()
        state.model_name = 'turtlebot3'
        state.pose.position.x = x
        print(x)
        state.pose.position.y = y
        print(y)
        if orient == None:
            state.pose.orientation = self.generate_quaternion_z(angle = None)
        self.gazebo_model_state_publisher.publish(state)

def main(args=None):


    server_ip_address = "192.168.1.3" # Gab's boarding house IP address
    rclpy.init(args=args)
    sensors_subscriber = SensorsSubscriber(server_ip_address = server_ip_address)
    rclpy.spin(sensors_subscriber)
    sensors_subscriber.destroy_node()

if __name__ == '__main__':

    main()
