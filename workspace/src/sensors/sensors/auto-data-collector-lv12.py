# Mostly Copy-pasted from capstone.py

import rclpy
import time
import threading
import socket
import sys
import struct
import random
import math

from rclpy.node import Node
from nav_msgs.msg import Odometry
from rclpy.qos import qos_profile_sensor_data
from geometry_msgs.msg import Twist
import numpy as np
from copy import deepcopy

from KNetworking import DataBridgeClient_TCP, DataBridgeServer_TCP

def quaternion_to_yaw(x, y, z, w): # Generated by GPT-4
    """
    Convert a quaternion into yaw (rotation around z-axis in radians)
    """
    t3 = +2.0 * (w * z + x * y)
    t4 = +1.0 - 2.0 * (y * y + z * z)
    yaw_z = math.atan2(t3, t4)
    return yaw_z

def yaw_difference(quaternion1, quaternion2): # Generated by GPT-4
    """
    Calculate the difference in yaw between two quaternions
    """
    yaw1 = quaternion_to_yaw(*quaternion1)
    yaw2 = quaternion_to_yaw(*quaternion2)
    
    # Calculate the difference and adjust for the circular nature of angles
    difference = yaw2 - yaw1
    difference = (difference + math.pi) % (2 * math.pi) - math.pi
    
    return difference

def normalize_radians(float_num):
    return (float_num + np.pi) % (2 * np.pi) - np.pi
    
class AutoDataCollector(Node):

    def __init__(self):

        super().__init__('AutoDataCollector_lv1_lv2')

        self.create_subscription(Odometry, 'odom', self.odometer_callback, qos_profile_sensor_data)
      
        self.movement_publisher = self.create_publisher(Twist, '/cmd_vel',10)
        self.starting_odometry_set = False
        # class-wide variables to be used
        self.distance_traveled = 0.0
        self.degrees_rotated = 0.0
        self.angle_threshold = 0.01
        self.odometry_msg_data = (None, None, None, None)
        # instantiate server connection
        server_port = 50000
        flag_connected = False
        self.send_lock = True # signals that new data is allowed to be transmitted

        # self.data_transfer_client = DataBridgeClient_TCP(destination_port=50000)
        # self.listener_thread = threading.Thread(self.instruction_listener)
        # self.listener_thread.start()

        
        self.test_thread = threading.Thread(target=self.sample)
        self.test_thread.start()

    def sample(self):

        while self.odometry_msg_data == (None, None, None, None): time.sleep(1); print('waiting...'); 
        print('test 0.2')
        self.rotate_x_radians_left(0.2)

        print('test 0.75')
        self.rotate_x_radians_left(0.75)

        print('test 1.0')
        self.rotate_x_radians_left(1)

        print('test 2.0')
        self.rotate_x_radians_left(2)

        print('test 3.0')
        self.rotate_x_radians_left(3)

        print('test pi')
        self.rotate_x_radians_left(math.pi)

    def reset_distance_and_radians(self):

        self.distance_traveled = 0.0
        self.degrees_rotated = 0.0
        self.starting_odometry_set = False

    
    def odometer_callback(self,msg):
        if msg == None: return
        
        if not self.starting_odometry_set: 
            self.starting_odometry_set = True
        else:
            q = self.odometry_msg.pose.pose.position
            x, y, z = q.x, q.y, q.z # save the values before proceeding
            q = self.odometry_msg.pose.pose.orientation
            quart = (q.x,q.y,q.z,q.w)

        self.odometry_msg = msg
        self.odometry_msg_data = (
            msg.pose.pose.orientation.x,
            msg.pose.pose.orientation.y,
            msg.pose.pose.orientation.z,
            msg.pose.pose.orientation.w,
        )

        try:

            q = self.odometry_msg.pose.pose.position
            x1, y1, z1 = q.x, q.y, q.z # save the values before proceeding
            q = self.odometry_msg.pose.pose.orientation
            quart2 = (q.x,q.y,q.z,q.w)
            self.distance_traveled += math.sqrt((x1-x)**2 + (y1-y)**2 + (z1-z)**2)
            self.degrees_rotated += yaw_difference(quart2, quart)
            # print((round(self.distance_traveled,2),round(self.degrees_rotated * 180 / math.pi,2)))

        except Exception as e:
            pass

    def print_log(self, mess:str):

        print(f"[AutoDataCollector: {time.ctime()}] " + mess)

    def __publish_twist_message(self, linear_x, angular_z):

        data = Twist()
        data.linear.x = linear_x
        data.angular.z = angular_z
        self.movement_publisher.publish(data)
        
        return

    def move_x_meters_feedback(self, distance, vel_x:float = 0.2): # accurate, works up to +- 0.005 meters

        # implement here
        current = deepcopy(self.distance_traveled) # updates at a separate thread
        end_loop = False
        while not end_loop:

            delta = distance - (self.distance_traveled - current) # should approach zero
            
            progress = delta / distance # should also approach zero
            x = 0.2
            print(delta, progress)
            if delta > 0.025: # if delta is bigger than some amount
                x = 0.2
            
            else:
                x = 0.05

            if progress < 0.001:
                self.__publish_twist_message(0.0, 0.0)
                end_loop = True

            self.__publish_twist_message(linear_x = x, angular_z = 0.0)
            time.sleep(0.1) # 10 hz to avoid overwhelming limited processor power
        
    def rotate_x_radians_left(self, angular_distance_radians, angl_vel_z:float = 1.0): # WARNING: only works from 0 to pi
        
        start = quaternion_to_yaw(*self.odometry_msg_data)
        current_orientation =  quaternion_to_yaw(*self.odometry_msg_data)
        target_orientation = normalize_radians(current_orientation + angular_distance_radians) # normalize to -pi to pi

        end_loop = False

        while not end_loop:

            current_orientation = normalize_radians(quaternion_to_yaw(*self.odometry_msg_data))
            rotation_remaining = normalize_radians(target_orientation - current_orientation)
            
            if rotation_remaining < 0.01:
                end_loop = True
                self.__publish_twist_message(0.0, 0.0)
                break

            if rotation_remaining > 0.5:
                z = angl_vel_z
            else:
                z = 0.2

            self.__publish_twist_message(0.0,z)
            
            time.sleep(0.1)
        
        end = quaternion_to_yaw(*self.odometry_msg_data)
        print('delta:', normalize_radians(end - start))

    def rotate_x_radians_right(self, angular_distance_radians, angl_vel_z:float = 1.5): # WARNING: only works from 0 to pi
        
        start = quaternion_to_yaw(*self.odometry_msg_data)

        current_orientation = quaternion_to_yaw(*self.odometry_msg_data)
        # For right rotation, subtract the angle to get the target orientation
        target_orientation = normalize_radians(current_orientation - angular_distance_radians)  # normalize to -pi to pi
        end_loop = False
        while not end_loop:
            current_orientation = normalize_radians(quaternion_to_yaw(*self.odometry_msg_data))
            rotation_remaining = -normalize_radians(target_orientation - current_orientation)
            if rotation_remaining < 0.01:
                end_loop = True
                self.__publish_twist_message(0.0, 0.0)
                break

            # Determine progress and adjust angular velocity accordingly

            if rotation_remaining > 0.5:
                z = -angl_vel_z  # Negative value for right (clockwise) rotation

            else:
                z = -0.2  # Maintain a minimum speed for final adjustments

            self.__publish_twist_message(0.0, z)
            time.sleep(0.1)
         
        end = quaternion_to_yaw(*self.odometry_msg_data)
        
        print('delta:', normalize_radians(end - start))


def main(args=None):

    rclpy.init(args=args)

    sensors_subscriber = AutoDataCollector()
    rclpy.spin(sensors_subscriber)
    sensors_subscriber.destroy_node()

if __name__ == '__main__':

    main()
